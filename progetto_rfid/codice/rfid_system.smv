MODULE main

VAR
 r : reader(t1,t2);
 t1: tag(r,0ub8_0000_0000,1,t2);
 t2: tag(r,0ub8_0000_0000,1,t1);

-- verifichiamo se tutti gli stati dei tag
-- sono raggiungibili


-- hard test
/--CTLSPEC
AG(!t1.new_addr=0ub8_0000_0001)
CTLSPEC
AG(!(t1.state=end) & !(t2.state=end))
CTLSPEC
AG(!(r.state=end))
LTLSPEC
F(G(t1.state=collision))->G(F(r.state=idle))--/
/--LTLSPEC
G(X(X(X(X(X(t1.state=collision))))))
LTLSPEC
G(X(X(X(X(X(X(t1.state=collision)))))))--/
CTLSPEC
EF(t2.state=end)
CTLSPEC
EF(t1.state=end)
CTLSPEC
EF(t1.new_addr=0ub8_0000_0001 & t2.new_addr=0ub8_0000_0000)
CTLSPEC
EF(t1.new_addr=0ub8_0000_0000)

-- verifichiamo se il reader rimane in deadlock
-- in una particolare configurazione

MODULE reader(t1,t2)

VAR
 continue: boolean;
 bit     : -1..8;
 a       : unsigned word[1];
 state   : {transmit,receive,idle,collision_bit,
            collision,single_bit,single,end};


-- collision detection
DEFINE 
  k := count((t1.state=transmit),(t2.state=transmit));

ASSIGN

    init(continue) := TRUE;
    next(continue) := 
        case
           state=end : FALSE;
           TRUE : continue;
        esac;

    init(a) := 0ub1_0;
    next(a) := 
        case
           (bit=1) & (state=collision)           : 0ub1_0;
           (bit=1) & (state=single) & (a=0ub1_0) : 0ub1_1;
           TRUE : a;
        esac;

    init(bit) := 0;
    next(bit) :=
        case
          -- collision
          (state=collision_bit) & (bit=0)           :  1;

          -- single
          (t1.state=end) & (t2.state=end)           : -1;
          (state=single_bit) & (bit=1) & (a=0ub1_0) :  1;
          TRUE : bit;
        esac;


    init(state) := transmit;
    next(state) :=
        case
          (continue=TRUE) & (state=transmit)                : receive;
          (k=0) & (state=receive)                           : idle;
          (k>=2) & ((state=receive) | (state=idle))         : collision_bit;
          (k=1) & ((state=receive) | (state=idle))          : single_bit;
          (state=collision_bit)                             : collision;
          (state=single_bit)                                : single;
          (bit=-1) & ((state=idle) | (state=single))        : end;
          (state=idle) | (state=collision) | (state=single) : transmit;
          TRUE : state;
        esac;


MODULE tag(r,address,s_bit,t)

VAR
 continue : boolean;
 solved   : boolean; 
 coin     : {0,1};
 new_addr : unsigned word[8];
 bit_e    : unsigned word[1];
 state    : {receive,transmit,collision,single,end};


-- bit's extraction 
DEFINE
  extraction := (state=end)? -1 : coin;

ASSIGN

    init(continue) := TRUE;
    next(continue) := 
        case
           state=end : FALSE;
           TRUE : continue;
        esac;

    next(coin) := {0,1};

    init(solved) := FALSE;
    next(solved) := 
        case
           (state=collision) & (extraction!=t.extraction) : TRUE;
           (state!=collision)                             : FALSE;
           TRUE : solved;
        esac;
    
    init(bit_e) := 0ub1_0;
    next(bit_e) :=
        case
           (state=collision) & !(solved) & (extraction=0) : 0ub1_0;
           (state=collision) & !(solved) & (extraction=1) : 0ub1_1;
           TRUE                                           : bit_e;
        esac;
    
    init(new_addr) := address;
    next(new_addr) := 
        case
           (solved) : resize(address,7)::bit_e;
           TRUE : new_addr;
        esac;

     
    init(state) := receive;   
    next(state) :=
        case
           (state=receive) & 
           (((r.state=receive) & (r.bit=0)) |  
           ((r.state=receive) & (r.bit=1) & (r.a=resize(new_addr,1)))) : transmit;
           (r.state=collision) & (state=transmit)                      : collision;
           (r.state=single) & (state=transmit)                         : single;
           (state=collision) & (solved)                                : receive;
           (state=single)                                              : end;
           TRUE : state;
        esac;



    -- resize(new_addr >> (s_bit - (s_bit - 1)),1)



 
