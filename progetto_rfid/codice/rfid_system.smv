MODULE main

VAR
 r : reader(t1,t2);
 t1: tag1(r,0ub8_0000_0000,1);
 t2: tag2(r,0ub8_0000_0001,1);

-- verifichiamo se tutti gli stati dei tag
-- sono raggiungibili

/--CTLSPEC
EF(t1.state=transmit)
CTLSPEC
EF(t1.state=receive)
CTLSPEC
EF(t1.state=collision)
CTLSPEC
EF(t1.state=single)
CTLSPEC
EF(t1.state=end)
--/
CTLSPEC
EF(t2.state=transmit)
CTLSPEC
EF(t2.state=receive)
CTLSPEC
EF(t2.state=collision)
CTLSPEC
EF(t2.state=single)
CTLSPEC
EF(t2.state=end)
CTLSPEC
EF(t2.length=1)
CTLSPEC
EF(t2.value=one)
CTLSPEC
EF(t2.state=equal)
CTLSPEC
EF(t2.state=equal_1)
CTLSPEC
EF(t1.state=single)
CTLSPEC
AG(EF(r.k=1))

-- verifichiamo se il reader rimane in deadlock
-- in una particolare configurazione

/--CTLSPEC
AG(EF(r.state=transmit))
CTLSPEC
AG(EF(r.state=receive))
CTLSPEC
AG(EF(r.state=idle))
CTLSPEC
AG(EF(r.state=collision))
CTLSPEC
AG(EF(r.state=single))
CTLSPEC
AG(EF(r.state=single_bit))
CTLSPEC
AG(EF(r.state=end))
CTLSPEC
AG(EF(r.bit=1))
--/

MODULE reader(t1,t2)

VAR
 continue: boolean;
 bit     : -1..8;
 a       : unsigned word[1];
 state   : {transmit,receive,idle,collision_bit,
            collision,single_bit,single,end};
 
-- reader's address
/--DEFINE
  a := (bit=1) & (state=collision) ? 
       0ub1_0 :
       (bit=2) & (state=single) & (resize(b,sizeof(b)-1)=0ub1_1) ? 
       0ub1_1 :
       (bit=1) & (state=single) & (a=0ub1_0) ? 
       0ub1_1 : 0ub1_0;--/

/--DEFINE
  b := (bit=2) & (state=collision) ?
       a :: 0ub1_0 :
       (bit=3) & (state=single) & (resize(c,sizeof(c)-1)=0ub1_1) ?
       resize(c,1) :
       (bit=2) & (state=single) & (resize(b,sizeof(b)-1)=0ub1_0) ?
       resize(b,1) :: 0ub1_1 : 0ub1_00;--/



-- collision detection
DEFINE 
  k := ((t1.state=transmit) & (t2.state=transmit) )  ? 2 :
       ((t1.state=transmit) & !(t2.state=transmit))  ? 1 :
       (!(t1.state=transmit) & (t2.state=transmit))  ? 1 : 0;

ASSIGN

    init(continue) := TRUE;
    next(continue) := 
        case
           state=end : FALSE;
           TRUE : continue;
        esac;

    init(a) := 0ub1_0;
    next(a) := 
        case
           (bit=1) & (state=collision)           : 0ub1_0;
           (bit=1) & (state=single) & (a=0ub1_0) : 0ub1_1;
           TRUE : a;
        esac;

    init(bit) := 0;
    next(bit) :=
        case
          ((state=collision_bit) & (bit=0)) |  
          ((state=single_bit) & (bit=1) & (a=0ub1_0)) :  1;
          (state=single_bit) & (bit=1) & (a=0ub1_1)   : -1;
          TRUE : bit;
        esac;


    init(state) := transmit;
    next(state) :=
        case
          (continue=TRUE) & (state=transmit)                : receive;
          (k=0) & (state=receive)                           : idle;
          (k>=2) & ((state=receive) | (state=idle))         : collision_bit;
          (k=1) & ((state=receive) | (state=idle))          : single_bit;
          (state=collision_bit)                             : collision;
          (state=single_bit)                                : single;
          (bit=-1) & ((state=idle) | (state=single))        : end;
          (state=idle) | (state=collision) | (state=single) : transmit;
          TRUE : state;
        esac;



MODULE tag1(r,address,significant_bit)

VAR
 continue : boolean;
 value    : {alt, empty, one};
 state    : {receive,equal,equal_1,transmit,collision,single,end};
 

-- length of address' tag
DEFINE
  length := (r.state=receive) & (significant_bit >= r.bit) ? 1 : 0;



ASSIGN

    init(continue) := TRUE;
    next(continue) := 
        case
           state=end : FALSE;
           TRUE : continue;
        esac;

    init(value) := alt;
    next(value) :=
        case
          -- (state!=equal)            : alt;
           (state=equal) & (r.bit=0) : empty;
           (state=equal) & (r.bit=1) : one;
           TRUE : value;
        esac;

    init(state) := receive;
    next(state) :=
        case
           (r.state=receive) & (length=1) & (state=receive) : equal;
           (state=equal)                                    : equal_1;
           --(state=equal_1) & (value=alt)                    : receive;
           (state=equal_1) & ((value=empty) | 
           ((value=one) & (r.a=0ub1_0)))    : transmit;
           (r.state=collision) & (state=transmit)           : collision;
           (r.state=single) & (state=transmit)              : single;
           (state=collision)                                : receive;
           (state=single)                                   : end;
           TRUE : state;
        esac;
 


MODULE tag2(r,address,significant_bit)

VAR
 continue : boolean;
 value    : {alt, empty, one};
 state    : {receive,equal,equal_1,transmit,collision,single,end};
 

-- length of address' tag
DEFINE
  length := (r.state=receive) & (significant_bit >= r.bit) ? 1 : 0;



ASSIGN

    init(continue) := TRUE;
    next(continue) := 
        case
           state=end : FALSE;
           TRUE : continue;
        esac;

    init(value) := alt;
    next(value) :=
        case
          -- (state!=equal)            : alt;
           (state=equal) & (r.bit=0) : empty;
           (state=equal) & (r.bit=1) : one;
           TRUE : value;
        esac;

    init(state) := receive;
    next(state) :=
        case
           (r.state=receive) & (length=1) & (state=receive) : equal;
           (state=equal)                                    : equal_1;
           --(state=equal_1) & (value=alt)                    : receive;
           (state=equal_1) & ((value=empty) | 
           ((value=one) & (r.a=0ub1_1)))    : transmit;
           (r.state=collision) & (state=transmit)           : collision;
           (r.state=single) & (state=transmit)              : single;
           (state=collision)                                : receive;
           (state=single)                                   : end;
           TRUE : state;
        esac;



    



 
