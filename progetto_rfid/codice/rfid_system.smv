MODULE main

VAR
 r : reader(t1,t2);
 t1: tag(r,0);
 t2: tag(r,1);

-- verifichiamo se tutti gli stati dei tag
-- sono raggiungibili

CTLSPEC
EF(t1.state=transmit)
CTLSPEC
EF(t1.state=receive)
CTLSPEC
EF(t1.state=collision)
CTLSPEC
EF(t1.state=single)
CTLSPEC
EF(t1.state=end)

CTLSPEC
EF(t2.state=transmit)
CTLSPEC
EF(t2.state=receive)
CTLSPEC
EF(t2.state=collision)
CTLSPEC
EF(t2.state=single)
CTLSPEC
EF(t2.state=end)

-- verifichiamo se il reader rimane in deadlock
-- in una particolare configurazione

--CTLSPEC
--AG(EF(r.state=transmit))
--CTLSPEC
--AG(EF(r.state=receive))
--CTLSPEC
--AG(EF(r.state=idle))
--CTLSPEC
--AG(EF(r.state=collision))
--CTLSPEC
--AG(EF(r.state=single))
--CTLSPEC
--AG(EF(r.state=end))

MODULE reader(t1,t2)

VAR
 continue: boolean;
 address : {-1,0,1};
 state   : {transmit,receive,idle,collision,single,end};
 


-- collision detection
DEFINE 
  k := ((t1.state=transmit) & (t2.state=transmit) )  ? 2 :
       ((t1.state=transmit) & !(t2.state=transmit))  ? 1 :
       (!(t1.state=transmit) & (t2.state=transmit))  ? 1 : 0;

ASSIGN

    init(continue) := TRUE;
    next(continue) := 
        case
           state=end : FALSE;
           TRUE : continue;
        esac;

    init(address) := -1;
    next(address) :=
        case
         (state=collision) : 0;
         (state=single) & (address=0) : 1;
         (state=single) & (address=1) : -1;
         TRUE : address;
        esac;

    init(state) := transmit;
    next(state) :=
        case
          (continue=TRUE) & (state=transmit)                : receive;
          (k=0) & (state=receive)                           : idle;
          (k>=2) & ((state=receive) | (state=idle))         : collision;
          (k=1) & ((state=receive) | (state=idle))          : single;
          (address=-1) & ((state=idle) | (state=single))    : end;
          (state=idle) | (state=collision) | (state=single) : transmit;
          TRUE : state;
        esac;



MODULE tag(r,a)

VAR
 continue: boolean;
 address : {-1,0,1};
 state   : {receive,transmit,collision,single,end};
 

ASSIGN

    init(continue) := TRUE;
    next(continue) := 
        case
           state=end : FALSE;
           TRUE : continue;
        esac;

    init(address) := -1;
    next(address) :=
        case
          (state=collision) : a;
          TRUE : address;
        esac; 

    init(state) := receive;
    next(state) :=
        case
           (r.state=receive) & (r.address=address) & (state=receive): transmit;
           (r.state=collision) & (state=transmit)                   : collision;
           (r.state=single) & (state=transmit)                      : single;
           (state=collision)                                        : receive;
           (state=single)                                           : end;
           TRUE : state;
        esac;



    



 


